package pro.api4.jsonapi4j.operation;

import pro.api4.jsonapi4j.processor.CursorPageableResponse;
import pro.api4.jsonapi4j.request.JsonApiRequest;
import pro.api4.jsonapi4j.operation.validation.JsonApi4jDefaultValidator;
import pro.api4.jsonapi4j.model.document.error.ErrorsDoc;

import java.util.List;

/**
 * Implement this interface to let jsonapi4j framework to know how to read multiple resources. This implies both
 * 'read all (with or without pagination)' and 'read by filters' flows that limits 'read all' by applying extra filters.
 * It's up to developers to decide whether to support multi-filter implementation or single-filter implementation based
 * on the priorities of the existing filters.
 * <p>
 * Follows the JSON:API specification regarding <a href="https://jsonapi.org/format/#fetching-resources">resource fetching</a>.
 * Available under GET /{resourceType} - with various 'filter[foo]=b,a,r' query params or without.
 * Returns 200 if executed successfully.
 * <p>
 * It's highly recommended to have at least 'filter by id' flow implemented since it streamlines Compound Docs resolutions.
 * Generated by default JSON:API 'links' also rely on 'filter[id]' filter when composing 'related' section.
 * <p>
 * If jsonapi4j framework is not managed to find the corresponding resource {@link ReadMultipleResourcesOperation} in
 * {@link OperationsRegistry} it automatically tries to fall back to {@link ReadResourceByIdOperation} that mimics
 * this operation by using a sequential bruteforce approach that reads resources one by one which is far from being ideal.
 * <p>
 * Main logic is supposed to be implemented in {@link #readPage(JsonApiRequest)} Usually, this method looks like:
 * <pre>
 *     {@code
 *     @Override
 *     public CursorPageableResponse<DownstreamCountry> readPage(JsonApiRequest request) {
 *         if (request.getFilters().containsKey(ID_FILTER_NAME)) {
 *             return CursorPageableResponse.fromItemsNotPageable(
 *                     // read by ids
 *             );
 *         } else if (request.getFilters().containsKey(REGION_FILTER_NAME)) {
 *             return CursorPageableResponse.fromItemsPageable(
 *                     , // read by region
 *                     request.getCursor()
 *             );
 *         } else {
 *             return CursorPageableResponse.fromItemsPageable(
 *                     , // read all countries with pagination
 *                     request.getCursor()
 *             );
 *         }
 *     }
 *     }
 * </pre>
 * But depending on the domain specifics it might only implement 'readById' (and, probably, other filters).
 * But 'read all' flow might not exist for some resources.
 * <p>
 * It is recommended to complement the main logic implementation with some validation logic by implementing
 * {@link #validate(JsonApiRequest)} method. This method invoked before the main logic execution.
 * All checks regarding input parameters, their formats, supported flows must be done there.
 * Don't bring these checks to the {@link #readPage(JsonApiRequest)}. If some error detected thrown exception will be
 * automatically processed and transformed into a valid {@link ErrorsDoc}.
 *
 * @param <RESOURCE_DTO> a downstream object type that encapsulates internal model implementation and of this
 *                       JSON:API resource, e.g. Hibernate's Entity, JOOQ Record, or third-party service DTO
 */
public interface ReadMultipleResourcesOperation<RESOURCE_DTO> extends ResourceOperation {

    String ID_FILTER_NAME = "id";

    /**
     * Reads multiple resources. Implies 'read all' by default, but can be limited by filters. In some situations only
     * 'read by id' filter flow might exist.
     * <p>
     * It's highly recommended to have at least 'filter by id' flow implemented since framework heavily rely on it
     * by default.
     *
     * @param request incoming {@link JsonApiRequest}
     * @return {@link CursorPageableResponse} of downstream {@link RESOURCE_DTO}
     */
    CursorPageableResponse<RESOURCE_DTO> readPage(JsonApiRequest request);

    /**
     * Overrides NO-OP implementation by {@link ReadMultipleResourcesOperation}-specific default validations, namely it
     * applies some basic checks for 'filter[id]' flow if this is the current flow (e.g. max number of ids,
     * max length of each id, etc.).
     * <p>
     * Thus, it's recommended to call
     * <pre>
     *     {@code
     *     ReadMultipleResourcesOperation.super.validate(request);
     *     }
     * </pre>
     * at the beginning of the custom method implementation.
     * <p>
     * Must throw an exception if validation failed. Check DefaultErrorHandlerFactory, Jsr380ErrorHandlers,
     * etc. for more details.
     *
     * @param request incoming {@link JsonApiRequest}
     */
    @Override
    default void validate(JsonApiRequest request) {
        List<String> ids = request.getFilters().get(ID_FILTER_NAME);
        if (ids != null && !ids.isEmpty()) {
            new JsonApi4jDefaultValidator().validateFilterByIds(ids);
        }
    }

}
